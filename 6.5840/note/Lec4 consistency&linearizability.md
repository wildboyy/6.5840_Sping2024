# Consistency & Linearizability

> 我们需要能够推理网络服务的行为
> 
> 例如：对于 lab2 的 server ，我们应该抱有何种期待，期待它能 100% 不丢包，还是期待它 req 和 resp 都会有一定概率丢失。对于一个网络服务的不同判断，会影响我们的编程

--- 

## 一致性模型

上述例子引出了一个概念：**一致性模型**

**何为一致性模型？**

 a specification for the relationship of different clients' views of a service

关于服务在不同客户视角下关系的规范

**为什么需要一致性模型？**

如果一个服务不提供一致性模型，那么应用则很难确保正确。

而且服务本身也很难设计/实现/优化

一致性模型的种类很多，本章讨论的是linearizability（可线性化）

## 可线性化（特定条件下的）

> **可线性化**：分布式系统中的一致性模型，要求每个操作看起来在**某个瞬时原子性完成**，所有后续操作都能立即看到其效果。
> 
> 像是所有的操作都是有严格的先后顺序，且在时间轴上不重合。
> 
> 也被称为强一致性

可线性化的服务非常符合程序员的直觉和思维，但同时也很难优化（性能受限）。

### 历史线

定义：一条时间线，并发的操作按照开始和结束的时间分布在各自的时间线上。

```
C1:---|--Wx1--|-----------|--Wx2--|-----
C2:---------|------Rx2-------|----------

// Wx1 表示把 1 写入 x ，即 put("x", 1)
// Rx2 表示读取 x 的值为 2，即 get("x") --> 2
```

如果可以从每个操作中选取一个时间点来代表这个操作。吧这所有的时间点串起来按照顺序原子性的执行，得到的结果和历史一样。则一段历史是可线性化的，

上面的示例就是可线性化的。

现在考虑如下例子:

```java
C1:---|--Wx1--|-----------|-------Wx2--------|-----
C2:--------------｜---Rx2----|-------------------
C3:-------------------------------|--Rx1--|------
```

这是一个不可线性化的history。无论如何选取点

1、Rx1 操作都永远在 Rx2 操作之后，

2、Rx2 永远在 Wx1 之后

所以一个线性的执行不可能在读取到 2 之后再读取到 1

**但是**

为何并发的情况下，就可以出现这种情况呢。举个例子

服务器是有主从备份的，C2 在Rx2 时读取的是主节点的值，C3 在 Rx1 的时候可能读取的是从节点的值！

当然还有一些其他可能性，比如 Rx1 读取的时候，server 崩溃重启，且尚未对 Wx2 操作进行恢复，这时就会读取到旧值。

可线性化一致性 的要求会排除掉很多有吸引力的设计，例如

1. 多个领导者
2. 在宕机重启后允许忘记已经写入的部分数据
3. 允许从未更新的从节点读数据

### 如何实现可线性化

取决于想要多少复制，多大缓存，多少的容错。

#### 单节点情况

fifo 执行请求即可，通过重复请求检查机制  + resp 缓存机制来解决重复请求的问题

#### 高可用情况

单节点最大问题是可用性不高，节点崩了服务就挂了

想要高可用，就要主从复制

如何实现可线性化呢？（一主二从模式）

1. 请求全部到主节点

2. 主节点选择一个请求序列，并发送给从节点

3. 所有从节点按照顺序执行请求

4. 所有节点执行完毕后，主节点才向客户返回响应

由此，client 收到响应时表示所有节点都已经执行完毕，如果主节点挂了，任意从节点都可以继续服务，且已经执行的结果不会丢失。保证了高可用

该情况下，不能让 client 直接访问从节点，否则会出现读未提交。

需要一个**外部仲裁者**，来决定何时让从节点升级为主节点。

### 性能

可线性化的要求会使得性能下降，原因：

1. 串行要求导致难以并发加速

2. 主从复制导致大量通信

3. 主从复制，副本必须可达，这会限制容错能力（即牺牲可用性，宕机会导致服务暂时不可用）

但是，如果key 是独立的，则可以进行分片

## 其他一致性模型

会有更好的性能吗?

会有直观的语义吗

### 最终一致性

read 会请求任意一个 replica

write 会更新在任何一个 replica，当那个 replica 被更新后，client 就会得到response

对于其他 replica 的更新，会在后台继续进行，最终会达成一致

最终一致性模型非常流行，它快，它高容错

### 最终一致性的问题

1. 读未提交（读的不是最新数据）

2. 写的失序

3. 不同 client 读到不同数据

4. 如何解决写冲突（对同一个 key 的写入操作），如何保证所有replica 写的结果一致

5. 无法实现 test_and_set

## 原则

一个通用的原则是，在以下性质中二选一

1. 强一致性 C

2. 高可用性 A

但这两者是矛盾的

强一致性要求等待节点同步，且当多数节点不可达时，就必须等待节点恢复

相对的，高可用则必须放弃强一致性。
