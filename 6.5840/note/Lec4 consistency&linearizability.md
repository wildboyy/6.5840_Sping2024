# Consistency & Linearizability

> 我们需要能够推理网络服务的行为
> 
> 例如：对于 lab2 的 server ，我们应该抱有何种期待，期待它能 100% 不丢包，还是期待它 req 和 resp 都会有一定概率丢失。对于一个网络服务的不同判断，会影响我们的编程

--- 

## 一致性模型

上述例子引出了一个概念：**一致性模型**

**何为一致性模型？**

 a specification for the relationship of different clients' views of a service

关于服务在不同客户视角下关系的规范

**为什么需要一致性模型？**

如果一个服务不提供一致性模型，那么应用则很难确保正确。

而且服务本身也很难设计/实现/优化

一致性模型的种类很多，本章讨论的是linearizability（可线性化）



## 可线性化（特定条件下的）

> **可线性化**：分布式系统中的一致性模型，要求每个操作看起来在**某个瞬时原子性完成**，所有后续操作都能立即看到其效果。
> 
> 像是所有的操作都是有严格的先后顺序，且在时间轴上不重合。
> 
> 也被称为强一致性

可线性化的服务非常符合程序员的直觉和思维，但同时也很难优化（性能受限）。

### 历史线

定义：一条时间线，并发的操作按照开始和结束的时间分布在各自的时间线上。

```
C1:---|--Wx1--|-----------|--Wx2--|-----
C2:---------|------Rx2-------|----------

// Wx1 表示把 1 写入 x ，即 put("x", 1)
// Rx2 表示读取 x 的值为 2，即 get("x") --> 2
```

如果可以从每个操作中选取一个时间点来代表这个操作。吧这所有的时间点串起来按照顺序原子性的执行，得到的结果和历史一样。则一段历史是可线性化的，

上面的示例就是可线性化的。

现在考虑如下例子:

```java
C1:---|--Wx1--|-----------|-------Wx2--------|-----
C2:--------------｜---Rx2----|-------------------
C3:-------------------------------|--Rx1--|------
```

这是一个不可线性化的history。无论如何选取点

1、Rx1 操作都永远在 Rx2 操作之后，

2、Rx2 永远在 Wx1 之后

所以一个线性的执行不可能在读取到 2 之后再读取到 1

**但是**

为何并发的情况下，就可以出现这种情况呢。举个例子

服务器是有主从备份的，C2 在Rx2 时读取的是主节点的值，C3 在 Rx1 的时候可能读取的是从节点的值！

当然还有一些其他可能性，比如 Rx1 读取的时候，server 崩溃重启，且尚未对 Wx2 操作进行恢复，这时就会读取到旧值。

可线性化一致性 的要求会排除掉很多有吸引力的设计，例如

1. 多个领导者
2. 在宕机重启后允许忘记已经写入的部分数据
3. 允许从未更新的从节点读数据





### 如何实现可线性化

取决于想要多少复制，多大缓存，多少的容错。



#### 单节点情况

fifo 执行请求即可，通过重复请求检查机制  + resp 缓存机制来解决重复请求的问题



#### 高可用情况

单节点最大问题是可用性不高，节点崩了服务就挂了

想要高可用，就要主从复制
