# Lecture 2: Threads and RPC

### 主题：

分布式系统的实现，实验中的go编程，go线程，网络爬虫，go rpc



### 为什么选择 Go 语言？

- 对协程（轻量级线程）有很好的支持
- 具备便捷的远程过程调用（RPC）机制
- 类型安全（即减少出现因类型不匹配导致的问题）且内存安全
- 拥有垃圾回收机制（避免释放内存后仍使用的问题）
  - 协程与垃圾回收机制的结合尤其有吸引力！
- 不太复杂
- Go 语言常用于分布式系统中



### 有没有线程的替代方案？ 

有，

编写在单线程中明确交织执行多个活动的代码。 这通常被称为“事件驱动”编程。 

为每个活动（例如每个客户端请求）维护一个状态表。 有一个“事件”循环，它会： - 检查每个活动是否有新的输入（例如，来自服务器的响应到达）； - 为每个活动执行下一步操作； - 更新状态。 

事件驱动编程可以实现 I/O 并发， 并且消除了线程开销（这种开销可能相当大）， 但无法利用多核处理器实现加速， 而且编程过程很痛苦。 



### 多线程挑战

共享数据安全

“竞争”：多个线程同时操作同一块内存

解决竞争的方法：

1. 锁
2. 避免共享可变数据

线程间如何协作？

用 Go channels ，sync.Cond, sync.WaitGroup

死锁？





### **Let's look at the tutorial's web crawler as a threading example.**

---

#### 什么是爬虫？

目标：获取所有网页，来喂给索引器

给一个初始网页，它递归的进入所有的链接，但是不重复返回同一个页面，也不会陷入循环链接



#### 爬虫的挑战：

利用IO并发：网络延迟影响很大，并行抓取网页，使用线程实现并发

每个URL只爬一次：避免浪费带宽，避免循环链接，记录已经访问的URL

确定爬虫结束时间



### 三种爬虫solution

crawler.go提供了三种爬虫方案

---

连续执行

并发，通过共享数据控制

并发，通过通道控制







